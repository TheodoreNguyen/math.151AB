function [SplineX, SplineY, Sx, Sy] = proj2(option, file)
	%INPUT
	% --->The valid input for 'option' is an integer 1 or 2 determining which boundary condition to use
	% if option = 1, the Natural Boundary Condition is used, and if option = 2, the Clamped is used.
	% --->'file' is a string that is the name of the data file to be loaded. The data file is of type
	% scalar structure, and contains a field called "ip", and ip is an n by 3 matrix, where the 
	% first column are t values, the second col is x values, and the third is y values.
	%OUTPUT
	% ---->SplineX and SplineY are the result of cubic spline interpolation with respect to x and y
	% respectively. It is a concatenation of the n-1 generated cubic polynomials from the method
	% and is a piecewise-defined function over the interval of the smallest to the largest t
	% value, closed boundary, and defined as 0 outside of that latter interval.
	% -----> Sx and Sy are cells of size n-1, which house each of the n-1 generated cubic polynomials
	% at each of its entries. SplineX and SplineY are generated by adding all the function handle
	% entries of Sx and Sy together.
	
	
	%give feedback on the option selection
	if option == 1
		fprintf('You have chosen to use the Natural Boundary Condition in interpolation.\n');
	elseif option == 2
		fprintf('You have chosen to use the Clamped Boundary Condition in interpolation.\n');
	else
		fprintf('Invalid condition input. Please Enter as argument the integer 1 or 2.\n');
		return;
	end

	%load data from file
	data = load(file);
	%set data structure of array into a data structure on matlab/octave
	Data = data.ip;
	%obtain # rows of data matrix of columns (t = time | x(t) | y(t))
	[n, cols] = size(Data);
	%initialize vector of t, x(t), and y(t) to extract to, then extract the values
	t = [];
	x = [];
	y = [];
	for i = 1:n
		t(end + 1) = Data(i, 1);
		x(end + 1) = Data(i, 2);
		y(end + 1) = Data(i, 3);
	end

	%initialize vectors containing values for the b, c, d coefficients we want in the end
	Bx = [];
	Cx = [];
	Dx = [];

	By = [];
	Cy = [];
	Dy = [];

	for i = 1:(n-1)
		Bx(end + 1) = 0;
		Cx(end + 1) = 0;
		Dx(end + 1) = 0;
		
		By(end + 1) = 0;
		Cy(end + 1) = 0;
		Dy(end + 1) = 0;
	end

	%H is h_i = t_i+1 - t_i, for i = 0... n-1  -> we initialize and give values to array of h-values used later
	H = [];
	for i = 1:(n-1)
		H(end + 1) = t(i + 1) - t(i);
	end

	
	% M is the solution, A is the tridiagonal matrix, R is the vector values in AM = R, M is second derivative we want
	Mx = [];
	My = [];
	A = [];
	Rx = [];
	Ry = [];
	Mu = [];
	Lmda = [];

	%create Mu array 
	if option == 1			%NBC condition
		Mu(end + 1) = 0;
	elseif option == 2		%CBC condition
		Mu(end + 1) = 1;
	else
		fprintf('How did you get this far if the condition option was not 1 or 2?\n');
		return;
	end

	for i = 2:(n - 1)
		Mu(end + 1) = ( H(i) / ( H(i - 1) + H(i) ) );
	end



	%create Lmda array 
	for i = 1:(n - 2)
		Lmda(end + 1) = 1 - Mu(i);
	end

	if option == 1			%NBC condition
		Lmda(end + 1) = 0;
	elseif option == 2		%CBC condition
		Lmda(end + 1) = 1;
	else
		fprintf('How did you get this far if the condition option was not 1 or 2?\n');
		return;
	end


	%precompute f' using five-point endpoint formula in case of option 2 CBC
	h = (t(2) - t(1));
	dxzero = ((1/(12*h)) * (-25*x(1) + 48*x(2) - 36*x(3) + 16*x(4) - 3*x(5)));
	dxnth = ((1/(12*h)) * (-25*x(n) + 48*x(n - 1) - 36*x(n - 2) + 16*x(n - 3) - 3*x(n - 4)));
	dyzero = ((1/(12*h)) * (-25*y(1) + 48*y(2) - 36*y(3) + 16*y(4) - 3*y(5)));
	dynth = ((1/(12*h)) * (-25*y(n) + 48*y(n - 1) - 36*y(n - 2) + 16*y(n - 3) - 3*y(n - 4)));

	%create R array for for x-values
	if option == 1			%NBC condition
		Rx(end + 1) = 0;
	else					%CBC condition
		Rx(end + 1) = ( ((6/(H(1)^2))*(x(2) - x(1))) - ((6/H(1))*dxzero) ); 
	end

	for i = 1:(n - 2)
		Rx(end + 1) = (6 / (H(i + 1) + H(i))) * ( ((x(i+2)-x(i+1))/H(i + 1)) - ((x(i+1) - x(i))/H(i)) );
	end

	if option == 1			%NBC condition
		Rx(end + 1) = 0;
	else					%CBC condition
		Rx(end + 1) = ((6/H(n - 1))*dxnth) - (6*(x(n) - x(n - 1))/(H(n -1)^2));
	end

	
	%do the same for Y : create R array for y-values
	if option == 1			%NBC condition
		Ry(end + 1) = 0;
	else					%CBC condition
		Ry(end + 1) = ( ((6/(H(1)^2))*(y(2) - y(1))) - ((6/H(1))*dyzero) ); 
	end

	for i = 1:(n - 2)
		Ry(end + 1) = (6 / (H(i + 1) + H(i))) * ( ((y(i+2)-y(i+1))/H(i + 1)) - ((y(i+1) - y(i))/H(i)) );
	end

	if option == 1			%NBC condition
		Ry(end + 1) = 0;
	else					%CBC condition
		Ry(end + 1) = ((6/H(n - 1))*dynth) - (6*(y(n) - y(n - 1))/(H(n -1)^2));
	end


	%create the tridiagonal matrix A
	for i = 1:n
		for j = 1:n
			if i == j
				A(i, j) = 2;
			elseif j == (i + 1)
				A(i, j) = Mu(i);
			elseif (i - j) == 1
				A(i, j) = Lmda(j);
			else
				A(i, j) = 0;
			end
		end
	end

	%call croutsolver to solve the linear system AM = R for M
	Mx = CroutSolver(A, Rx);
	My = CroutSolver(A, Ry);
	if option == 1		%NBC condition; CBC does not alter M(1) or M(n)
		Mx(n) = 0;
		My(n) = 0;
		Mx(1) = 0;
		My(1) = 0;
	end

	%solve for coefficients 
	for i = 1:(n-1)
		Bx(i) = ((x(i + 1) - x(i))/H(i)) - ((H(i)/6) * (Mx(i + 1) + 2*Mx(i)));
		By(i) = ((y(i + 1) - y(i))/H(i)) - ((H(i)/6) * (My(i + 1) + 2*My(i)));
		Cx(i) = (Mx(i)/2);
		Cy(i) = (My(i)/2);
		Dx(i) = (Mx(i + 1) - Mx(i))/(6*H(i));
		Dy(i) = (My(i + 1) - My(i))/(6*H(i));
	end

	%creating the cubic spline function
	%create a cell that will hold all n-1 cubic functions
	Sx = {};
	Sy = {};
	%add the those n-1 functions to the cell entries
	for i = 1:(n-1)
		if i ~= (n-1)
			Sx{end + 1} = @(T) (x(i)+Bx(i)*(T-t(i))+Cx(i)*(T-t(i))^2 + Dx(i)*(T-t(i))^3).*(T >= t(i) & T < t(i+1));
			Sy{end + 1} = @(T) (y(i)+By(i)*(T-t(i))+Cy(i)*(T-t(i))^2 + Dy(i)*(T-t(i))^3).*(T >= t(i) & T < t(i+1));
		else	%have a closed bound on the piecewise at the last interval [tn-1, tn]
			Sx{end + 1} = @(T) (x(i)+Bx(i)*(T-t(i))+Cx(i)*(T-t(i))^2 + Dx(i)*(T-t(i))^3).*(T >= t(i) & T <= t(i+1));
			Sy{end + 1} = @(T) (y(i)+By(i)*(T-t(i))+Cy(i)*(T-t(i))^2 + Dy(i)*(T-t(i))^3).*(T >= t(i) & T <= t(i+1));
		end
	end
	
	%we now simply need to add all the cubic functions in each of the cell entries to create our piecewise spline
	%function. HOWEVER, because we are using anonymous functions, they cannot be added together without some sort
	%of conditioning. So, we have to add them together as a cumulative sum to make them work right
	
	%this method was chosen rather than using heaviside functions, holdon/hold off, etc for lack for a better 
	%knowledge of matlab, and so the function is continuous and vectorized and can be called to evaluate at 
	%any point. Point is, it works, so why not?
	
	SplineXsum = {};
	SplineYsum = {};
	SplineXsum{1} = Sx{1};
	SplineYsum{1} = Sy{1};
	for i = 2:(n-1)
		SplineXsum{i} = @(T) SplineXsum{i - 1}(T) + Sx{i}(T);
		SplineYsum{i} = @(T) SplineYsum{i - 1}(T) + Sy{i}(T);
	end
	
	%These are our final piecewise cubic splines.
	SplineX = SplineXsum{n - 1};
	SplineY = SplineYsum{n - 1};


end